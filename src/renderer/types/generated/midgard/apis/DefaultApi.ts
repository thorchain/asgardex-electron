// tslint:disable
/**
 * Midgard Public API
 * The Midgard Public API queries THORChain and any chains linked via the Bifr√∂st and prepares information about the network to be readily available for public users. The API parses transaction event data from THORChain and stores them in a time-series database to make time-dependent queries easy. Midgard does not hold critical information. To interact with BEPSwap and Asgardex, users should query THORChain directly.
 *
 * The version of the OpenAPI document: 2.0.0-alpha.2
 * Contact: devs@thorchain.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Observable } from 'rxjs';
import { BaseAPI, HttpQuery, throwIfNullOrUndefined, encodeURI } from '../runtime';
import {
    ConstantsSchema,
    DepthHistory,
    EarningsHistory,
    InlineResponse200,
    InlineResponse2001,
    InlineResponse2002,
    InlineResponse2003,
    InlineResponse2004,
    LiquidityHistory,
    MemberDetails,
    Network,
    NodeKey,
    PoolDetail,
    StatsData,
    SwapHistory,
} from '../models';

export interface GetDepthHistoryRequest {
    pool: string;
    interval: GetDepthHistoryIntervalEnum;
    from: number;
    to: number;
}

export interface GetEarningsHistoryRequest {
    interval: GetEarningsHistoryIntervalEnum;
    from: number;
    to: number;
}

export interface GetLiquidityHistoryRequest {
    interval: GetLiquidityHistoryIntervalEnum;
    from: number;
    to: number;
    pool?: number;
}

export interface GetMemberDetailRequest {
    address: string;
}

export interface GetPoolRequest {
    asset: string;
}

export interface GetPoolsRequest {
    status: GetPoolsStatusEnum;
}

export interface GetSwapHistoryRequest {
    interval: GetSwapHistoryIntervalEnum;
    from: number;
    to: number;
    pool?: string;
}

export interface GetTxDetailsRequest {
    limit: number;
    offset: number;
    address?: string;
    txid?: string;
    asset?: string;
    type?: string;
}

/**
 * no description
 */
export class DefaultApi extends BaseAPI {

    /**
     * Returns the asset and rune depths and price. The values report the state at the end of each interval.  Bucketing parameters: * Interval is required, possible values: 5min, hour, day, week, month, quarter, year. * count: optional int, (1..100) * from/to: optional int, unix second.  Providing all count/from/to will result in error. Possible configurations: * last 10 days: interval=day&count=10 * last 10 days before to: interval=day&count=10&to=1234567890 * interval=day&count=10&from=1234567890    - next 10 days after from. * interval=day&from=1100000&to=1100000     - days between from and to. It will fail if more than 100 intervals are requested. 
     * Depth and price history
     */
    getDepthHistory = ({ pool, interval, from, to }: GetDepthHistoryRequest): Observable<DepthHistory> => {
        throwIfNullOrUndefined(pool, 'getDepthHistory');
        throwIfNullOrUndefined(interval, 'getDepthHistory');
        throwIfNullOrUndefined(from, 'getDepthHistory');
        throwIfNullOrUndefined(to, 'getDepthHistory');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'interval': interval,
            'from': from,
            'to': to,
        };

        return this.request<DepthHistory>({
            path: '/v2/history/depths/{pool}'.replace('{pool}', encodeURI(pool)),
            method: 'GET',
            query,
        });
    };

    /**
     * Returns earnings data for the specified interval.
     * Earnings related history
     */
    getEarningsHistory = ({ interval, from, to }: GetEarningsHistoryRequest): Observable<EarningsHistory> => {
        throwIfNullOrUndefined(interval, 'getEarningsHistory');
        throwIfNullOrUndefined(from, 'getEarningsHistory');
        throwIfNullOrUndefined(to, 'getEarningsHistory');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'interval': interval,
            'from': from,
            'to': to,
        };

        return this.request<EarningsHistory>({
            path: '/v2/history/earnings',
            method: 'GET',
            query,
        });
    };

    /**
     * Returns an object containing the health response of the API
     * Get Health
     */
    getHealth = (): Observable<InlineResponse200> => {
        return this.request<InlineResponse200>({
            path: '/v2/health',
            method: 'GET',
        });
    };

    /**
     * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools
     * Liquidity changes related history
     */
    getLiquidityHistory = ({ interval, from, to, pool }: GetLiquidityHistoryRequest): Observable<LiquidityHistory> => {
        throwIfNullOrUndefined(interval, 'getLiquidityHistory');
        throwIfNullOrUndefined(from, 'getLiquidityHistory');
        throwIfNullOrUndefined(to, 'getLiquidityHistory');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'interval': interval,
            'from': from,
            'to': to,
        };

        if (pool != null) { query['pool'] = pool; }

        return this.request<LiquidityHistory>({
            path: '/v2/history/liquidity_changes',
            method: 'GET',
            query,
        });
    };

    /**
     * Returns an array of statistics per pool for a given member RUNE address.
     * Details of a member
     */
    getMemberDetail = ({ address }: GetMemberDetailRequest): Observable<MemberDetails> => {
        throwIfNullOrUndefined(address, 'getMemberDetail');

        return this.request<MemberDetails>({
            path: '/v2/members/{address}'.replace('{address}', encodeURI(address)),
            method: 'GET',
        });
    };

    /**
     * Returns an array containing the RUNE addresses for all members.
     * Get members
     */
    getMembersAdresses = (): Observable<Array<string>> => {
        return this.request<Array<string>>({
            path: '/v2/members',
            method: 'GET',
        });
    };

    /**
     * Returns an object containing Network data
     * Get Network Data
     */
    getNetworkData = (): Observable<Network> => {
        return this.request<Network>({
            path: '/v2/network',
            method: 'GET',
        });
    };

    /**
     * Returns an object containing Node public keys
     * Get Node public keys
     */
    getNodes = (): Observable<Array<NodeKey>> => {
        return this.request<Array<NodeKey>>({
            path: '/v2/nodes',
            method: 'GET',
        });
    };

    /**
     * Returns details of the pool: depths, price, 24h volume, APY. 
     * Get details for a specific pool
     */
    getPool = ({ asset }: GetPoolRequest): Observable<PoolDetail> => {
        throwIfNullOrUndefined(asset, 'getPool');

        return this.request<PoolDetail>({
            path: '/v2/pool/{asset}'.replace('{asset}', encodeURI(asset)),
            method: 'GET',
        });
    };

    /**
     * Returns an array containing details for a set of pools.
     * Get Asset Pools
     */
    getPools = ({ status }: GetPoolsRequest): Observable<Array<PoolDetail>> => {
        throwIfNullOrUndefined(status, 'getPools');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'status': status,
        };

        return this.request<Array<PoolDetail>>({
            path: '/v2/pools',
            method: 'GET',
            query,
        });
    };

    /**
     * Constant values used by THORChain , some of the values can be overrided by mimir
     * Get the Proxied THORChain Constants
     */
    getProxiedConstants = (): Observable<ConstantsSchema> => {
        return this.request<ConstantsSchema>({
            path: '/v2/thorchain/constants',
            method: 'GET',
        });
    };

    /**
     * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
     * Get the Proxied THORChain Inbound Addresses
     */
    getProxiedInboundAddresses = (): Observable<InlineResponse2001> => {
        return this.request<InlineResponse2001>({
            path: '/v2/thorchain/inbound_addresses',
            method: 'GET',
        });
    };

    /**
     * Retrieve lastest block infomation across all chains.
     * Get the Proxied THORChain Lastblock
     */
    getProxiedLastblock = (): Observable<InlineResponse2002> => {
        return this.request<InlineResponse2002>({
            path: '/v2/thorchain/lastblock',
            method: 'GET',
        });
    };

    /**
     * Returns the proxied queue endpoint from a local thornode
     * Get the Proxied THORChain Queue
     */
    getProxiedQueue = (): Observable<InlineResponse2003> => {
        return this.request<InlineResponse2003>({
            path: '/v2/thorchain/queue',
            method: 'GET',
        });
    };

    /**
     * Returns an object containing global stats for all pools and all transactions.
     * Get Global Stats
     */
    getStats = (): Observable<StatsData> => {
        return this.request<StatsData>({
            path: '/v2/stats',
            method: 'GET',
        });
    };

    /**
     * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools
     * Swaps related history
     */
    getSwapHistory = ({ interval, from, to, pool }: GetSwapHistoryRequest): Observable<SwapHistory> => {
        throwIfNullOrUndefined(interval, 'getSwapHistory');
        throwIfNullOrUndefined(from, 'getSwapHistory');
        throwIfNullOrUndefined(to, 'getSwapHistory');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'interval': interval,
            'from': from,
            'to': to,
        };

        if (pool != null) { query['pool'] = pool; }

        return this.request<SwapHistory>({
            path: '/v2/history/swaps',
            method: 'GET',
            query,
        });
    };

    /**
     * Return an array containing the event details
     * List transactions or get details for specific transactions.
     */
    getTxDetails = ({ limit, offset, address, txid, asset, type }: GetTxDetailsRequest): Observable<InlineResponse2004> => {
        throwIfNullOrUndefined(limit, 'getTxDetails');
        throwIfNullOrUndefined(offset, 'getTxDetails');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'limit': limit,
            'offset': offset,
        };

        if (address != null) { query['address'] = address; }
        if (txid != null) { query['txid'] = txid; }
        if (asset != null) { query['asset'] = asset; }
        if (type != null) { query['type'] = type; }

        return this.request<InlineResponse2004>({
            path: '/v2/tx',
            method: 'GET',
            query,
        });
    };

}

/**
 * @export
 * @enum {string}
 */
export enum GetDepthHistoryIntervalEnum {
    _5min = '5min',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
 * @export
 * @enum {string}
 */
export enum GetEarningsHistoryIntervalEnum {
    _5min = '5min',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
 * @export
 * @enum {string}
 */
export enum GetLiquidityHistoryIntervalEnum {
    _5min = '5min',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
 * @export
 * @enum {string}
 */
export enum GetPoolsStatusEnum {
    Available = 'available',
    Staged = 'staged',
    Suspended = 'suspended'
}
/**
 * @export
 * @enum {string}
 */
export enum GetSwapHistoryIntervalEnum {
    _5min = '5min',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
