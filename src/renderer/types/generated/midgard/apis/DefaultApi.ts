// tslint:disable
/**
 * Midgard Public API
 * The Midgard Public API queries THORChain and any chains linked via the Bifr√∂st and prepares information about the network to be readily available for public users. The API parses transaction event data from THORChain and stores them in a time-series database to make time-dependent queries easy. Midgard does not hold critical information. To interact with BEPSwap and Asgardex, users should query THORChain directly.
 *
 * The version of the OpenAPI document: 2.0.0-alpha.2
 * Contact: devs@thorchain.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Observable } from 'rxjs';
import { BaseAPI, HttpQuery, throwIfNullOrUndefined, encodeURI } from '../runtime';
import {
    Constants,
    DepthHistory,
    EarningsHistory,
    Health,
    InboundAddresses,
    InlineResponse200,
    Lastblock,
    LiquidityHistory,
    MemberDetails,
    Network,
    Node,
    PoolDetail,
    PoolLegacyDetail,
    PoolStatsDetail,
    Queue,
    StatsData,
    SwapHistory,
} from '../models';

export interface GetActionsRequest {
    limit: number;
    offset: number;
    address?: string;
    txid?: string;
    asset?: string;
    type?: string;
}

export interface GetDepthHistoryRequest {
    pool: string;
    interval?: GetDepthHistoryIntervalEnum;
    count?: number;
    to?: number;
    from?: number;
}

export interface GetEarningsHistoryRequest {
    interval?: GetEarningsHistoryIntervalEnum;
    count?: number;
    to?: number;
    from?: number;
}

export interface GetLiquidityHistoryRequest {
    pool?: string;
    interval?: GetLiquidityHistoryIntervalEnum;
    count?: number;
    to?: number;
    from?: number;
}

export interface GetMemberDetailRequest {
    address: string;
}

export interface GetPoolRequest {
    asset: string;
}

export interface GetPoolStatsRequest {
    asset: string;
    period?: GetPoolStatsPeriodEnum;
}

export interface GetPoolStatsLegacyRequest {
    asset: string;
}

export interface GetPoolsRequest {
    status?: GetPoolsStatusEnum;
}

export interface GetSwapHistoryRequest {
    pool?: string;
    interval?: GetSwapHistoryIntervalEnum;
    count?: number;
    to?: number;
    from?: number;
}

/**
 * no description
 */
export class DefaultApi extends BaseAPI {

    /**
     * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions. 
     * Actions List
     */
    getActions = ({ limit, offset, address, txid, asset, type }: GetActionsRequest): Observable<InlineResponse200> => {
        throwIfNullOrUndefined(limit, 'getActions');
        throwIfNullOrUndefined(offset, 'getActions');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'limit': limit,
            'offset': offset,
        };

        if (address != null) { query['address'] = address; }
        if (txid != null) { query['txid'] = txid; }
        if (asset != null) { query['asset'] = asset; }
        if (type != null) { query['type'] = type; }

        return this.request<InlineResponse200>({
            path: '/v2/actions',
            method: 'GET',
            query,
        });
    };

    /**
     * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * Depth and Price History
     */
    getDepthHistory = ({ pool, interval, count, to, from }: GetDepthHistoryRequest): Observable<DepthHistory> => {
        throwIfNullOrUndefined(pool, 'getDepthHistory');

        const query: HttpQuery = {};

        if (interval != null) { query['interval'] = interval; }
        if (count != null) { query['count'] = count; }
        if (to != null) { query['to'] = to; }
        if (from != null) { query['from'] = from; }

        return this.request<DepthHistory>({
            path: '/v2/history/depths/{pool}'.replace('{pool}', encodeURI(pool)),
            method: 'GET',
            query,
        });
    };

    /**
     * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * Earnings History
     */
    getEarningsHistory = ({ interval, count, to, from }: GetEarningsHistoryRequest): Observable<EarningsHistory> => {

        const query: HttpQuery = {};

        if (interval != null) { query['interval'] = interval; }
        if (count != null) { query['count'] = count; }
        if (to != null) { query['to'] = to; }
        if (from != null) { query['from'] = from; }

        return this.request<EarningsHistory>({
            path: '/v2/history/earnings',
            method: 'GET',
            query,
        });
    };

    /**
     * Returns an object containing the health response of the API
     * Health Info
     */
    getHealth = (): Observable<Health> => {
        return this.request<Health>({
            path: '/v2/health',
            method: 'GET',
        });
    };

    /**
     * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * Liquidity Changes History
     */
    getLiquidityHistory = ({ pool, interval, count, to, from }: GetLiquidityHistoryRequest): Observable<LiquidityHistory> => {

        const query: HttpQuery = {};

        if (pool != null) { query['pool'] = pool; }
        if (interval != null) { query['interval'] = interval; }
        if (count != null) { query['count'] = count; }
        if (to != null) { query['to'] = to; }
        if (from != null) { query['from'] = from; }

        return this.request<LiquidityHistory>({
            path: '/v2/history/liquidity_changes',
            method: 'GET',
            query,
        });
    };

    /**
     * Returns an array of statistics for all the liquidity providers associated with a given member address.
     * Member Details
     */
    getMemberDetail = ({ address }: GetMemberDetailRequest): Observable<MemberDetails> => {
        throwIfNullOrUndefined(address, 'getMemberDetail');

        return this.request<MemberDetails>({
            path: '/v2/member/{address}'.replace('{address}', encodeURI(address)),
            method: 'GET',
        });
    };

    /**
     * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown.
     * Members List
     */
    getMembersAdresses = (): Observable<Array<string>> => {
        return this.request<Array<string>>({
            path: '/v2/members',
            method: 'GET',
        });
    };

    /**
     * Returns an object containing Network data
     * Network Data
     */
    getNetworkData = (): Observable<Network> => {
        return this.request<Network>({
            path: '/v2/network',
            method: 'GET',
        });
    };

    /**
     * Returns a list of Node public keys and adresses.
     * Nodes List
     */
    getNodes = (): Observable<Array<Node>> => {
        return this.request<Array<Node>>({
            path: '/v2/nodes',
            method: 'GET',
        });
    };

    /**
     * Returns details of the pool: depths, price, 24h volume, APY. 
     * Details of a Pool
     */
    getPool = ({ asset }: GetPoolRequest): Observable<PoolDetail> => {
        throwIfNullOrUndefined(asset, 'getPool');

        return this.request<PoolDetail>({
            path: '/v2/pool/{asset}'.replace('{asset}', encodeURI(asset)),
            method: 'GET',
        });
    };

    /**
     * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns. 
     * Pool Statistics
     */
    getPoolStats = ({ asset, period }: GetPoolStatsRequest): Observable<PoolStatsDetail> => {
        throwIfNullOrUndefined(asset, 'getPoolStats');

        const query: HttpQuery = {};

        if (period != null) { query['period'] = period; }

        return this.request<PoolStatsDetail>({
            path: '/v2/pool/{asset}/stats'.replace('{asset}', encodeURI(asset)),
            method: 'GET',
            query,
        });
    };

    /**
     * Legacy, V1 style names for backward compatibility. Please migrate to GetPoolStats, check the fields documentation for details. 
     * Pool Statistics (v1 naming)
     */
    getPoolStatsLegacy = ({ asset }: GetPoolStatsLegacyRequest): Observable<PoolLegacyDetail> => {
        throwIfNullOrUndefined(asset, 'getPoolStatsLegacy');

        return this.request<PoolLegacyDetail>({
            path: '/v2/pool/{asset}/stats/legacy'.replace('{asset}', encodeURI(asset)),
            method: 'GET',
        });
    };

    /**
     * Returns an array containing details for a set of pools
     * Pools List
     */
    getPools = ({ status }: GetPoolsRequest): Observable<Array<PoolDetail>> => {

        const query: HttpQuery = {};

        if (status != null) { query['status'] = status; }

        return this.request<Array<PoolDetail>>({
            path: '/v2/pools',
            method: 'GET',
            query,
        });
    };

    /**
     * Constant values used by THORChain , some of the values can be overrided by mimir
     * Proxied THORChain Constants
     */
    getProxiedConstants = (): Observable<Constants> => {
        return this.request<Constants>({
            path: '/v2/thorchain/constants',
            method: 'GET',
        });
    };

    /**
     * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
     * Proxied THORChain Inbound Addresses
     */
    getProxiedInboundAddresses = (): Observable<InboundAddresses> => {
        return this.request<InboundAddresses>({
            path: '/v2/thorchain/inbound_addresses',
            method: 'GET',
        });
    };

    /**
     * Retrieve lastest block infomation across all chains.
     * Proxied THORChain Lastblock
     */
    getProxiedLastblock = (): Observable<Lastblock> => {
        return this.request<Lastblock>({
            path: '/v2/thorchain/lastblock',
            method: 'GET',
        });
    };

    /**
     * Returns the proxied queue endpoint from a local thornode
     * Proxied THORChain Queue
     */
    getProxiedQueue = (): Observable<Queue> => {
        return this.request<Queue>({
            path: '/v2/thorchain/queue',
            method: 'GET',
        });
    };

    /**
     * Returns an object containing global stats for all pools and all transactions
     * Global Stats
     */
    getStats = (): Observable<StatsData> => {
        return this.request<StatsData>({
            path: '/v2/stats',
            method: 'GET',
        });
    };

    /**
     * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * Swaps History
     */
    getSwapHistory = ({ pool, interval, count, to, from }: GetSwapHistoryRequest): Observable<SwapHistory> => {

        const query: HttpQuery = {};

        if (pool != null) { query['pool'] = pool; }
        if (interval != null) { query['interval'] = interval; }
        if (count != null) { query['count'] = count; }
        if (to != null) { query['to'] = to; }
        if (from != null) { query['from'] = from; }

        return this.request<SwapHistory>({
            path: '/v2/history/swaps',
            method: 'GET',
            query,
        });
    };

}

/**
 * @export
 * @enum {string}
 */
export enum GetDepthHistoryIntervalEnum {
    _5min = '5min',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
 * @export
 * @enum {string}
 */
export enum GetEarningsHistoryIntervalEnum {
    _5min = '5min',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
 * @export
 * @enum {string}
 */
export enum GetLiquidityHistoryIntervalEnum {
    _5min = '5min',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
 * @export
 * @enum {string}
 */
export enum GetPoolStatsPeriodEnum {
    _1h = '1h',
    _24h = '24h',
    _7d = '7d',
    _30d = '30d',
    _90d = '90d',
    _365d = '365d',
    All = 'all'
}
/**
 * @export
 * @enum {string}
 */
export enum GetPoolsStatusEnum {
    Available = 'available',
    Staged = 'staged',
    Suspended = 'suspended'
}
/**
 * @export
 * @enum {string}
 */
export enum GetSwapHistoryIntervalEnum {
    _5min = '5min',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
